import React from 'react';
import {setObjProperty, getObjProperty} from './utils';

export function createFormValidator(message, isValidFunction) {
    return {
        message : message,
        validatorFunction : isValidFunction,
        setRequired : false
    };
}

export function createIsRequiredFormValidator(message) {
    message = message || 'Pole jest wymagane';
    let validator = createFormValidator(message, function(value) {
        if (typeof value == 'string') {
            return !(value == null || value == undefined || value.trim().length == 0);
        } else {
            return value == undefined ? false : value;
        }
    });
    validator.setRequired = true;
    return validator;
}

export function createMinLengthFormValidator(minLength, message) {
    message = message || 'Mimimalna długość to ' + minLength;
    let validator = createFormValidator(message, function(value) {
        return ! (value == null || value == undefined || value.trim().length < minLength);
    });
    validator.setRequired = true;
    return validator;
}

export function createMaxLengthFormValidator(maxLength, message) {
    message = message || 'Maksymalna długość to ' + maxLength;
    let validator = createFormValidator(message, function(value) {
        return (value == null || value == undefined || value.trim().length < maxLength);
    });
    return validator;
}

export function createEqLengthFormValidator(eqLength, message) {
    message = message || 'Wymagana długość to ' + eqLength;
    let validator = createFormValidator(message, function(value) {
        return (value == null || value == undefined || value.trim().length == eqLength);
    });
    return validator;
}

export function createRegexLengthFormValidator(regex, message) {
    if (typeof regex === 'string') {
        regex = new RegExp(regex, "i");
    }
    message = message || 'Niewłaściwy format (' + regex + ')';
    let validator = createFormValidator(message, function(value) {
        if (value == undefined || value == null) {
            return true;
        }
        return regex.test(value);
    });
    return validator;
}



export class Input extends React.Component {
    static contextTypes = {
        wizard : React.PropTypes.object
    };

    static propTypes = {
        type : React.PropTypes.string.isRequired, // input type
        name : React.PropTypes.string.isRequired, // field name
        label : React.PropTypes.string.isRequired, // label
        required : React.PropTypes.bool, // if field is required
        instantValidation : React.PropTypes.bool, // if validate onChange event
        inputId : React.PropTypes.string, // id for an input otherwise autogenerated
        placeholder : React.PropTypes.string, // input placeholder
        validators : React.PropTypes.arrayOf(React.PropTypes.object), // validators
        className : React.PropTypes.string
    };

    static defaultProps = {
        required : false,
        validators : [],
        className: "",
        outerClassName: ""

    };

    constructor(props) {
        super();
        this.props = props;
        let required = props.required;
        props.validators.forEach((validator) => {
            if (validator.setRequired) {
                required = true;
            }
        });
        this.validators = props.validators.slice();
        this.state = { error : null, label : props.label, required : required };
        this.inputId = props.inputId || 'form-input-' + props.name;
        if (this.validators.length == 0 && props.required) {
            this.validators.push(createIsRequiredFormValidator());
        }
        this.handleChange = this.handleChange.bind(this);
        this.validate = this.validate.bind(this);
        this.value = this.value.bind(this);
        this._renderSelect = this._renderSelect.bind(this);
        this.orgOnChange = this.props.onChange;
    }


    componentWillMount() {
        // register field in form
        this.context.wizard.formInputs.push(this);
        //prepare props for input
        this.inputProps = Object.assign({}, this.props, {onChange:this.handleChange, id:this.inputId, value:this.context.wizard.formData[this.props.name]});
        delete this.inputProps.formData; // clear it
        delete this.inputProps.validators; // clear it
        delete this.inputProps.required; // clear it
        delete this.inputProps.options; // clear it
        delete this.inputProps.instantValidation; // clear it
        delete this.inputProps.defaultValue; // clear it
        delete this.inputProps.outerClassName;
        if (this.props.type == 'checkbox') {
            this.inputProps.className = (this.props.className ? ' ' + this.props.className : '') + ' form-wizard-input form-wizard-input-' + this.props.type;
        } else {
            this.inputProps.className = 'form-control' + (this.props.className ? ' ' + this.props.className : '') + ' form-wizard-input form-wizard-input-' + this.props.type;
        }
    }

    componentWillUnmount() {
        // TODO unregister from wizard
    }

    validate() {
        let value = getObjProperty(this.context.wizard.formData, this.props.name);
        for(let i=0; i<this.validators.length; i++) {
            let validator = this.validators[i];
            let isValid = validator.validatorFunction(value);
            if (! isValid) {
               this.setState({error : validator.message});
               return false;
            }
        }
        this.setState({error : null});
        return true;
    }

    value(newValue) {
        const name = this.props.name;
        const data = this.context.wizard.formData;
        const old = getObjProperty(data, name);
        if (newValue != undefined) { // set new value
            const nv = newValue == '' ? null : newValue;
            if (nv != old) {
                setObjProperty(data, name, nv);
                let instantValidation = this.props.instantValidation;
                if (instantValidation == undefined) {
                    instantValidation = this.context.wizard.props.instantValidation;
                }
                if (instantValidation) {
                    this.validate();
                }
                this.forceUpdate();
            }
        }
        return old;
    }

    handleChange(event) {
        let val = event.target.value;
        if (event.target.type == 'checkbox') {
            val = event.target.checked;
            if (val == undefined || val == null) {
                val = false;
            }
        }
        if (val == undefined || val == null) {
            return val;
        }
        if (event.target.type == 'number') {
            val = parseInt(val);
        }
        this.value(val == undefined ? null : val);
        if (this.orgOnChange) {
            this.orgOnChange(event);
        }
    }


    _renderSelect(options) {
        let opts = [];
        opts.push((<option key="" value=""></option>));
        let isa = Array.isArray(options);
        for (let key in options) {
            let val = options[key];
            let rk = isa ? val : key;
            opts.push((<option label={val} value={rk} key={rk}>{val}</option>));
        }
        return (<select {...this.inputProps} value={dv}>{opts}</select>);
    }


    render() {
        const name = this.props.name;
        let type = this.props.type == undefined ? undefined : this.props.type.toLowerCase();
        if (type == 'checkbox') {
            return (<div className={` ${this.props.outerClassName} ${this.state.error != null ? 'has-error' : ''} `}>
                        <div className="checkbox"><label><input type="checkbox" {...this.inputProps} value={this.value()} />{this.props.label}</label></div>
                    </div>);
        } else {
            return (
                <div className={` ${this.props.outerClassName} `}>
                    <div className={`form-group ${this.props.className} ${this.state.error != null ? 'has-error' : ''}`}>
                        <label className="form-control-label" htmlFor={this.inputId}>{this.state.label}</label>
                        {(() => {
                            if (this.state.required) {
                                return (<span className="form-wizard-required"></span>);
                            }
                        })()}
                        {(() => {
                            let dv = this.value();
                            if (dv == null) {
                                dv = '';
                            }
                            if (this.props.options != undefined) { // select
                                if (type != undefined && type != 'select' && type != 'nice-select') {
                                    throw 'Cannot use options with type "' + type + '"';
                                }
                                return this._renderSelect(this.props.options);
                            }
                            type = type || 'text';
                            if (type == 'textarea') {
                                return (<textarea {...this.inputProps} value={dv}/>);
                            } else {
                                return (<input type={type} {...this.inputProps} value={dv}/>);
                            }
                        })()}
                        {(() => {
                            if (this.state.error != null) {
                                return (
                                    <span className="help-block">{this.state.error}</span>
                                );
                            }
                        })()}
                    </div>
                </div>
            );
        }
    }
}

export class Form extends React.Component {
    static childContextTypes = {
        wizard : React.PropTypes.object
    };

    static propTypes = {
        formData : React.PropTypes.object,   // where to save or get values
        instantValidation : React.PropTypes.bool,   // parameter to pass to Input(s)
        onValidationError : React.PropTypes.func,   // callback func(event, form)
        onSubmit : React.PropTypes.func             // callback func(event, form)
    };

    static defaultProps = {
        instantValidation : false,
        formData : {}
    };

    constructor(props) {
        super();
        this.props = props;
        this.formData = props.formData;
        this.formInputs = [];
        this.state = { };
        this.handleOnSubmit = this.handleOnSubmit.bind(this);
        this.data = this.data.bind(this);
    }

    data() {
        return this.formData;
    }

    getChildContext() {
        const self = this;
        return {
            wizard: self
        };
    }


    handleOnSubmit(event) {
        event.preventDefault();
        console.debug("Submit (Form)", event, this.formData);
        // validation
        let ret = true;
        this.formInputs.forEach((fin) => {
            if (! fin.validate()) {
                ret = false;
            }
        });
        if (ret) {
            if (this.props.onSubmit) {
                this.props.onSubmit(event, this);
            }
        } else {
            if (this.props.onValidationError) {
                this.props.onValidationError(event, this);
            }
        }
    }

    render() {
        return (<form {...this.props} onSubmit={this.handleOnSubmit}>
            {this.props.children}
        </form>);
    }

}
